C51 COMPILER V8.08   MAIN                                                                  05/31/2021 17:14:58 PAGE 1   


C51 COMPILER V8.08, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN Main.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE Main.c LARGE BROWSE DEBUG OBJECTEXTEND

line level    source

   1          #include <ADuC841.h>
   2          #include <stdio.h>
   3          
   4          #include "COBS_Kirale.h"
*** WARNING C280 IN LINE 298 OF COBS_KIRALE.H: 'tx': unreferenced local variable
*** WARNING C231 IN LINE 319 OF COBS_KIRALE.H: '_memset': attempt to redefine intrinsic function
   5          
   6          
   7          
   8          /**************** FPGA Communication Port: ********************/
   9          sbit TrigByte1N  = P0^7;                   
  10          sbit Ack1N       = P0^6;          
  11          sbit TrigByte2N  = P0^5;
  12          sbit Ack2N       = P0^4;
  13          sbit SelTrigger  = P0^3;
  14          sbit reset_fpga  = P0^0;
  15          /**************************************************************/
  16          
  17          unsigned char DATA_L;
  18          unsigned char DATA_H;
  19          unsigned int sizeRpl;
  20          unsigned int i, p;
  21          
  22          
  23          uint8_t cadena[512];
  24          uint8_t decoded[512];
  25          uint8_t dato;
  26          unsigned char flag, c;
  27          
  28          unsigned int result,Temp,Hum, LDR, cuenta_temp, cuenta_hum; 
  29          
  30          unsigned int resulti[2];
  31          
  32          /***************** Timer Configuration: **************************/
  33          void _WS_Timer_Config(char value)
  34          {
  35   1              IEIP2   = 0xA4; // TIC Interruption enable
  36   1              SEC     = 0x00;
  37   1              HTHSEC  = 0x00;
  38   1              MIN             = 0x00;
  39   1              HOUR    = 0x00;
  40   1              INTVAL  = value;        //**(Config.)   
  41   1              TIMECON = 0x53;         // The timer interrupt each second **(Config.)  /* 0x43 = 1/128 seconds */
  42   1      }       
  43          /*****************************************************************/
  44          
  45          /***************** ADC Configuration: ****************************/
  46          void _WS_ADC_Config (void)
  47          {
  48   1              ADCCON1  = 0xAC;     // ADCCON1: ADC Configuration: 12 clock periods for each conversion.              
             -                                                       
  49   1              ADCCON2  = 0x03;     // Selects channel 3 & on demand conversion.  (LDR is connected to the ADC3)
  50   1      }
  51          /*****************************************************************/
  52          
C51 COMPILER V8.08   MAIN                                                                  05/31/2021 17:14:58 PAGE 2   

  53          /***************** UART configuration: ***************************/
  54          void _WSN_UART841_config()
  55          {
  56   1              SCON = 0x52;//SCON: UART Serial Port Control Register   => Mode 1: 8-bit UART, variable baud rate
  57   1              PCON = 0x80;//PCON: power-saving options and general-purpose status flags => SMOD=1 (Double UART Baud Rat
             -e)
  58   1              
  59   1              TMOD = 0x21;//Timer 1 Set M1 for 8-bit autoreload timer, Timer 0 Set M0 16-bit 
  60   1              TH1 =  0xFA; // 115200 ADuC841        //TH1 holds a value which is to be reloaded into TL1 each time it o
             -verflows. (BaudRate = 19200 bps)
  61   1              TR1  = 1;   //Start timer 1
  62   1      
  63   1              TI  = 1;   //bit1(SCON): Serial Port Transmit Interrupt Flag.
  64   1              ES  = 0;        // Serial Port interruption disable
  65   1              ET1 = 0;        // Timer 1 Interruption Disable 
  66   1      
  67   1              EA  = 1;        // Global Enable Interruption Flag
  68   1      }
  69          /****************************************************************/
  70          
  71          /****************** ADC Conversion: *****************************/
  72          int _WSN_ADC_conversion()
  73          {
  74   1              unsigned int sensorData;
  75   1      
  76   1              //*** Sigle conversion:
  77   1              SCONV = 1;
  78   1              while (SCONV == 1);
  79   1      
  80   1              sensorData = ((ADCDATAH & 0x0F) * 0x0100) + ADCDATAL;
  81   1              
  82   1              SCONV = 0; // Conversion Flag
  83   1              
  84   1              return (sensorData);
  85   1      
  86   1      }
  87          /*****************************************************************/
  88          
  89          /****************** FPGA Initial config. *************************/
  90          void _WSN_ini_FPGA(void)
  91          { 
  92   1                 TrigByte1N  = 1;                
  93   1                 TrigByte2N  = 1;
  94   1                 SelTrigger  = 0;
  95   1                 reset_fpga  = 1;
  96   1      }
  97          /****************** FPGA-DATA capture: **************************/
  98          int _WSN_FPGA(bit sensorSelector)
  99          {     
 100   1         unsigned int fpga_data;
 101   1               
 102   1         SelTrigger  = sensorSelector;
 103   1         TrigByte1N = 0; 
 104   1         while (Ack1N == 1){};
 105   1         
 106   1         DATA_L = P2;            // LSB
 107   1         TrigByte1N = 1;         // Release Trigger1
 108   1          
 109   1         TrigByte2N = 0;         //Trigger second data byte
 110   1         while (Ack2N == 1){};
 111   1         
 112   1         DATA_H = P2;           // MSB
C51 COMPILER V8.08   MAIN                                                                  05/31/2021 17:14:58 PAGE 3   

 113   1         TrigByte2N = 1;    // Release Trigger2
 114   1      
 115   1      
 116   1         fpga_data = DATA_L + 256*(int)DATA_H;
 117   1      
 118   1         return(fpga_data);  
 119   1         
 120   1      }
 121          /*****************************************************************/
 122                                                                                                                                                  
 123          /***************** Timer Interruption: ***************************/
 124          void _WSN_interrupt_TimeInterval() interrupt 10 using 3 
 125          { 
 126   1         //unsigned int result,Temp,Hum,LDR,Axis;
 127   1      
 128   1            /** DO NOT EDIT *********/
 129   1                 c++;
 130   1                 if (c==2){
 131   2                   reset_fpga = 0;
 132   2                       reset_fpga = 1;
 133   2                       c = 0;
 134   2                 }   
 135   1                /************************/
 136   1         
 137   1         
 138   1         flag = 1;
 139   1      
 140   1            
 141   1      }
 142          /*****************************************************************/
 143          
 144          /***************** Sensors reading functionalities: ***************/
 145          void _WSN_sensors_reading(void){
 146   1      
 147   1         int result[2], i;
 148   1         int estado;
 149   1         static int cuenta = 0;
 150   1         cuenta++;
 151   1      
 152   1              /** _WSN_FPGA(0) = Temperature, ACC Y **/
 153   1              if(cuenta%cuenta_temp == 0)
 154   1              {
 155   2                      result[0] = _WSN_FPGA(0); 
 156   2                      Temp = (result[0] - (273.15*100)); 
 157   2                      printf("La temperatura son %.2f grados celsius\n", ((float)Temp)/100);
 158   2                      if(Temp>=25)
 159   2                              estado = 1;
 160   2                      else if(Temp<25)
 161   2                              estado = 2;
 162   2              }
 163   1      
 164   1              for(i=0;i<100;i++);
 165   1      
 166   1              /** _WSN_FPGA(1) = Humidity, ACC X **/ 
 167   1              if(cuenta%cuenta_hum == 0)
 168   1              {
 169   2                      result[1] = _WSN_FPGA(1);  
 170   2              Hum =  ( (result[1]*127.0)/100 );  
 171   2                      printf("Hay una humedad del %.2f %c\n", ((float)Hum)/100,37);   
 172   2              }
 173   1      
 174   1      
C51 COMPILER V8.08   MAIN                                                                  05/31/2021 17:14:58 PAGE 4   

 175   1         /************ Temp: ******************/
 176   1         // the temperature value taken from the FPGA has     to be
 177   1         // substracted from 27315 in order to show Degree Celsius x 100                              
 178   1         // Ej: Temp =  ( result - (273.15*100) );      // Degree Celsius x 100
 179   1         // c = 0;
 180   1         /*************************************/
 181   1              
 182   1      
 183   1         /************ Humidity ***************/
 184   1         // the humidity value taken form the FPGA has to be multipled
 185   1         // by 127.5 and divided by 100 in order to show H% x 100.
 186   1         // Ej: Hum =  ( (result*127.0)/100 );
 187   1         // c = 0;
 188   1         /*************************************/
 189   1      
 190   1      
 191   1         /************ Light: ******************/
 192   1      
 193   1         /**************************************/     
 194   1      
 195   1      
 196   1      }
 197          /*****************************************************************/
 198          
 199          /****************** ZigBee read: *********************************/
 200          /** ASCII  = Value of the character to wait.
 201          /** getsmj = It allows to get caracters from the serial port and 
 202          /** print them until ASCII arrives. 
 203          **/
 204          
 205          void _WSN_wait_answer(char ASCII,char getmsj)
 206          {  
 207   1              unsigned char serial_read,enable;
 208   1      
 209   1              enable = 1;
 210   1        
 211   1                   do
 212   1                      {
 213   2                              serial_read = _getkey(); 
 214   2              
 215   2                              if (serial_read == ASCII) 
 216   2                              {                                                                                        
 217   3                                      enable = 0;
 218   3                              }
 219   2                              else if (getmsj == 1)
 220   2                              {
 221   3                                      putchar(serial_read);
 222   3                              }                       
 223   2                      }while (enable != 0);
 224   1      }
 225          /**************** ZigBee Configuration: ************************/
 226          void _WSN_ZigBee_config(char type)
 227          {       
 228   1              printf("ATS00=0004\r");
 229   1              _WSN_wait_answer('O',0);
 230   1              _WSN_wait_answer('K',0);
 231   1      
 232   1              printf("ATS02=0003\r");
 233   1              _WSN_wait_answer('O',0);
 234   1              _WSN_wait_answer('K',0);
 235   1      
 236   1              printf("ATS03=0000000000000003\r");
C51 COMPILER V8.08   MAIN                                                                  05/31/2021 17:14:58 PAGE 5   

 237   1              _WSN_wait_answer('O',0);
 238   1              _WSN_wait_answer('K',0);
 239   1      
 240   1              printf("AT+JN\r");
 241   1              _WSN_wait_answer('O',0);
 242   1              _WSN_wait_answer('K',0);
 243   1              
 244   1      }
*** WARNING C280 IN LINE 226 OF MAIN.C: 'type': unreferenced local variable
 245          /******************* Message Detection: *************************/
 246          void _WSN_message_detect()
 247          {  
 248   1              _WSN_wait_answer('U',0);
 249   1              _WSN_wait_answer(':',0);
 250   1              _WSN_wait_answer(',',1);
 251   1               putchar('\t');
 252   1              _WSN_wait_answer('=',0);
 253   1              _WSN_wait_answer(0x03,1); 
 254   1      }
 255          
 256          /*********** FUNCIONES PROPIAS***************/
 257          
 258          
 259          static uint8_t XOR_CKS(uint8_t *frame, size_t size)
 260          {
 261   1              uint8_t cks = 0;
 262   1              int i=0;
 263   1              while(i<size)
 264   1              {
 265   2                      if(i != CKS_POS)
 266   2                      {
 267   3                              cks ^= frame[i];
 268   3                      }
 269   2                      else
 270   2                      {
 271   3                              cks=cks;
 272   3                      }
 273   2                      i++;
 274   2              }
 275   1              return cks;
 276   1              
 277   1      }
 278          
 279          
 280          static void send(uint8_t *buffer, size_t size)
 281          {
 282   1              uint8_t _encodeBuffer[512];
 283   1              int i = 0;
 284   1              size_t numEncoded= 0;
 285   1              buffer[4]= XOR_CKS(buffer, size);
 286   1              numEncoded = encod(buffer, size, _encodeBuffer);
 287   1      
 288   1              printf("%c",PacketMarker);      
 289   1              for(i=0;i<numEncoded;i++)
 290   1              {
 291   2                       printf("%c",_encodeBuffer[i]);
 292   2              }
 293   1               printf("\n");
 294   1              //HAL_UART_Transmit(&PacketMarker,sizeof(PacketMarker),1000);
 295   1              //HAL_UART_Transmit(_encodeBuffer,sizeof(_encodeBuffer)/sizeof(_encodeBuffer[0]),1000);
 296   1                      
 297   1      }
C51 COMPILER V8.08   MAIN                                                                  05/31/2021 17:14:58 PAGE 6   

 298          
 299          
 300          static void receive(int len)
 301          {
 302   1              /*int payload;
 303   1              while(i<len)
 304   1              {
 305   1                      cadena[i]= _getkey();
 306   1                      i++;
 307   1              }
 308   1              for(p=1;p<len;p++)
 309   1                      printf("%c",cadena[p]);
 310   1              printf("\n");
 311   1              for(p=0;p<len;p++)
 312   1              {
 313   1                      cobs_decod(decoded, len, cadena[p]);
 314   1              }
 315   1              payload= (int) decoded[1];
 316   1      
 317   1              for(p=0;p<(5+payload);p++)
 318   1              {
 319   1                      if(p==0)
 320   1                              printf("%c", decoded[p]+0x0E);
 321   1                      else
 322   1                              printf("%c",decoded[p]);
 323   1              }*/
 324   1              int d=0;
 325   1              int result; // The variable result will stored the num of bytes decoded by the cobs_decode function //
             -The variable where the decoded buffer will be stored. If bigger responses are expected increment its size.
 326   1              do
 327   1              {
 328   2                      //Receiving the Response and decoding byte to byte.
 329   2                      //cadena[d]= _getkey();
 330   2                      result=cobs_decod(decoded,512, _getkey());
 331   2                      //d++;  
 332   2              }while(result == 0);
 333   1              if(result == -1)
 334   1                      printf("\nERROR\n");
 335   1              if(result > 0)
 336   1                      printf("BYTES = %d\n",result);
 337   1              for(p=1;p<result;p++)
 338   1                      printf("%c",decoded[p]);
 339   1      
 340   1      }
*** WARNING C280 IN LINE 300 OF MAIN.C: 'len': unreferenced local variable
 341          
 342          void delay()
 343          {
 344   1              if(flag == 1)
 345   1              {
 346   2                      flag = 0;
 347   2              }
 348   1              while(flag == 0)
 349   1              {
 350   2                      ;
 351   2              }
 352   1      }
 353          void InicioRed(char role)
 354          {
 355   1              send(OOB, (sizeof(OOB)/sizeof(OOB[0])));
 356   1              receive(6);
 357   1              i = 0;
C51 COMPILER V8.08   MAIN                                                                  05/31/2021 17:14:58 PAGE 7   

 358   1              delay();
 359   1              printf("\n");
 360   1              printf("\n");
 361   1              Role[5]= role;
 362   1              send(Role, (sizeof(Role)/sizeof(Role[0])));
 363   1              receive(7);
 364   1              i=0;
 365   1              printf("\n");
 366   1              printf("\n");
 367   1              delay();
 368   1              send(WriteChannel, (sizeof(WriteChannel)/sizeof(WriteChannel[0])));
 369   1              receive(6);
 370   1              printf("\n");
 371   1              printf("\n");   
 372   1              i = 0;
 373   1              delay();
 374   1              send(WritePANID, sizeof(WritePANID)/sizeof(WritePANID[0]));
 375   1              receive(6);
 376   1              printf("\n");
 377   1              printf("\n");
 378   1              i = 0;
 379   1              send(WriteNetName, sizeof(WriteNetName)/sizeof(WriteNetName[0]));
 380   1              receive(6);
 381   1              printf("\n");
 382   1              printf("\n");
 383   1              i = 0;
 384   1              delay();
 385   1              send(WriteMLocPref, sizeof(WriteMLocPref)/sizeof(WriteMLocPref[0]));
 386   1              receive(6);
 387   1              printf("\n");
 388   1              printf("\n");
 389   1              i = 0;
 390   1              delay();
 391   1              send(WriteMK, sizeof(WriteMK)/sizeof(WriteMK[0]));
 392   1              receive(6);
 393   1              printf("\n");
 394   1              printf("\n");
 395   1              i = 0;
 396   1              send(WriteExtPID, sizeof(WriteExtPID)/sizeof(WriteExtPID[0]));
 397   1              receive(6);
 398   1              printf("\n");
 399   1              printf("\n");
 400   1              i = 0;
 401   1              delay();
 402   1              send(WriteComCred, sizeof(WriteComCred)/sizeof(WriteComCred[0]));
 403   1              receive(6);
 404   1              printf("\n");
 405   1              printf("\n");
 406   1              i = 0;
 407   1              delay();
 408   1              send(WriteJoinCred, sizeof(WriteJoinCred)/sizeof(WriteJoinCred[0]));
 409   1              receive(6);
 410   1              printf("\n");
 411   1              printf("\n");
 412   1              i=0;
 413   1              delay();
 414   1              send(ifup,(sizeof(ifup)/sizeof(ifup[0])));
 415   1              receive(6);
 416   1              printf("\n");
 417   1              printf("\n");
 418   1      }
 419          /******************* Main Function: *****************************/
C51 COMPILER V8.08   MAIN                                                                  05/31/2021 17:14:58 PAGE 8   

 420          void main()
 421          {
 422   1        
 423   1         //---- Peripheral Configurations: -------------
 424   1      
 425   1         c = 0;
 426   1         flag = 0;
 427   1         _WS_Timer_Config(0x05);
 428   1         _WS_ADC_Config();
 429   1         _WSN_UART841_config();
 430   1         _WSN_ini_FPGA();
 431   1         //entrada cuenta humedad y temperatura por defecto
 432   1         cuenta_temp = 1;
 433   1         cuenta_hum = 5;
 434   1         //_WSN_ZigBee_config('a');
 435   1      
 436   1         // --------------------------------------------
 437   1              
 438   1              InicioRed(fed);
 439   1              printf ("\nConnected\n\r");                                
 440   1      
 441   1              while (1)
 442   1              {
 443   2                 if (flag == 1){
 444   3      
 445   3                      //send(ComClear, (sizeof(ComClear)/sizeof(ComClear[0])));       
 446   3      
 447   3                      flag = 0;
 448   3      
 449   3                      }                               
 450   2                                                        
 451   2              }
 452   1      
 453   1      }
 454          /****************************************************************/


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2704    ----
   CONSTANT SIZE    =    172    ----
   XDATA SIZE       =   1418     585
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       1
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  4 WARNING(S),  0 ERROR(S)
